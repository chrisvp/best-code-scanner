-- Database Schema and Configuration Export
-- Generated by export_schema_and_config.py
-- Contains: Full schema + config tables only (no scan data)

-- ==========================================
-- SCHEMA (CREATE TABLE statements)
-- ==========================================

CREATE TABLE agent_sessions (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	finding_id INTEGER, 
	draft_finding_id INTEGER, 
	status VARCHAR, 
	model_name VARCHAR, 
	verdict VARCHAR, 
	confidence INTEGER, 
	reasoning TEXT, 
	attack_path TEXT, 
	total_steps INTEGER, 
	max_steps INTEGER, 
	total_tokens INTEGER, 
	duration_ms FLOAT, 
	execution_trace JSON, 
	task_prompt TEXT, 
	prefetched_context JSON, 
	error_message TEXT, 
	created_at DATETIME, 
	completed_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id), 
	FOREIGN KEY(finding_id) REFERENCES findings (id), 
	FOREIGN KEY(draft_finding_id) REFERENCES draft_findings (id)
);

CREATE TABLE benchmark_cases (
	id INTEGER NOT NULL, 
	dataset_id INTEGER NOT NULL, 
	file_path VARCHAR NOT NULL, 
	content TEXT, 
	language VARCHAR, 
	is_vulnerable BOOLEAN, 
	expected_finding_type VARCHAR, 
	expected_severity VARCHAR, 
	description TEXT, 
	line_number INTEGER, 
	PRIMARY KEY (id), 
	FOREIGN KEY(dataset_id) REFERENCES benchmark_datasets (id)
);

CREATE TABLE benchmark_datasets (
	id INTEGER NOT NULL, 
	name VARCHAR NOT NULL, 
	description TEXT, 
	created_at DATETIME, 
	PRIMARY KEY (id), 
	UNIQUE (name)
);

CREATE TABLE benchmark_results (
	id INTEGER NOT NULL, 
	run_id INTEGER NOT NULL, 
	case_id INTEGER NOT NULL, 
	verdict VARCHAR NOT NULL, 
	model_response TEXT, 
	latency_ms FLOAT, 
	found_severity VARCHAR, 
	found_line INTEGER, 
	PRIMARY KEY (id), 
	FOREIGN KEY(run_id) REFERENCES benchmark_runs (id), 
	FOREIGN KEY(case_id) REFERENCES benchmark_cases (id)
);

CREATE TABLE benchmark_runs (
	id INTEGER NOT NULL, 
	dataset_id INTEGER NOT NULL, 
	model_id INTEGER NOT NULL, 
	prompt_template TEXT, 
	status VARCHAR, 
	total_cases INTEGER, 
	passed_cases INTEGER, 
	failed_cases INTEGER, 
	total_time_ms FLOAT, 
	avg_latency_ms FLOAT, 
	created_at DATETIME, 
	completed_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(dataset_id) REFERENCES benchmark_datasets (id), 
	FOREIGN KEY(model_id) REFERENCES model_configs (id)
);

CREATE TABLE draft_findings (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	chunk_id INTEGER, 
	title VARCHAR, 
	vulnerability_type VARCHAR, 
	severity VARCHAR, 
	line_number INTEGER, 
	snippet TEXT, 
	reason TEXT, 
	auto_detected BOOLEAN, 
	initial_votes INTEGER, 
	source_models JSON, 
	dedup_key VARCHAR, 
	status VARCHAR, 
	verification_notes TEXT, 
	verification_votes INTEGER, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id), 
	FOREIGN KEY(chunk_id) REFERENCES scan_file_chunks (id)
);

CREATE TABLE finding_comments (
	id INTEGER NOT NULL, 
	finding_id INTEGER NOT NULL, 
	user_id INTEGER NOT NULL, 
	comment TEXT NOT NULL, 
	action VARCHAR, 
	created_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(finding_id) REFERENCES findings (id) ON DELETE CASCADE, 
	FOREIGN KEY(user_id) REFERENCES users (id)
);

CREATE TABLE findings (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	verified_id INTEGER, 
	file_path VARCHAR NOT NULL, 
	line_number INTEGER, 
	severity VARCHAR, 
	description TEXT NOT NULL, 
	snippet TEXT, 
	remediation TEXT, 
	category VARCHAR, 
	cvss_score FLOAT, 
	vulnerability_details TEXT, 
	proof_of_concept TEXT, 
	corrected_code TEXT, 
	remediation_steps TEXT, 
	"references" TEXT, mr_review_id INTEGER REFERENCES mr_reviews(id), source_model TEXT, detected_at DATETIME, confidence_score REAL, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id), 
	FOREIGN KEY(verified_id) REFERENCES verified_findings (id)
);

CREATE TABLE generated_fixes (
	id INTEGER NOT NULL, 
	finding_id INTEGER NOT NULL, 
	fix_type VARCHAR NOT NULL, 
	model_name VARCHAR, 
	code TEXT NOT NULL, 
	reasoning TEXT, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	PRIMARY KEY (id), 
	FOREIGN KEY(finding_id) REFERENCES findings (id)
);

CREATE TABLE github_repos (
    id INTEGER PRIMARY KEY,
    name VARCHAR NOT NULL,
    github_url VARCHAR NOT NULL DEFAULT 'https://api.github.com',
    github_token VARCHAR,
    owner VARCHAR NOT NULL,
    repo VARCHAR NOT NULL,
    description VARCHAR,
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP
);

CREATE TABLE gitlab_repos (
	id INTEGER NOT NULL, 
	name VARCHAR NOT NULL, 
	gitlab_url VARCHAR NOT NULL, 
	gitlab_token VARCHAR, 
	project_id VARCHAR NOT NULL, 
	description VARCHAR, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	updated_at DATETIME, verify_ssl BOOLEAN DEFAULT 0, 
	PRIMARY KEY (id)
);

CREATE TABLE global_settings (
	id INTEGER NOT NULL, 
	"key" VARCHAR NOT NULL, 
	value TEXT, 
	value_type VARCHAR, 
	description TEXT, 
	updated_at DATETIME, 
	PRIMARY KEY (id)
);

CREATE TABLE import_relations (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	importer_file VARCHAR, 
	imported_module VARCHAR, 
	imported_names JSON, 
	resolved_file VARCHAR, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);

CREATE TABLE llm_call_metrics (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	model_name VARCHAR, 
	phase VARCHAR, 
	call_count INTEGER, 
	total_time_ms FLOAT, 
	tokens_in INTEGER, 
	tokens_out INTEGER, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);

CREATE TABLE llm_request_logs (id INTEGER PRIMARY KEY, scan_id INTEGER, mr_review_id INTEGER, model_name VARCHAR, phase VARCHAR, analyzer_name VARCHAR,
  file_path VARCHAR, chunk_id INTEGER, request_prompt TEXT, raw_response TEXT, parsed_result JSON, parse_success BOOLEAN DEFAULT 1, parse_error TEXT, findings_count INTEGER DEFAULT 0, tokens_in
  INTEGER, tokens_out INTEGER, duration_ms FLOAT, created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP);

CREATE TABLE model_configs (
	id INTEGER NOT NULL, 
	name VARCHAR, 
	base_url VARCHAR, 
	api_key VARCHAR, 
	max_tokens INTEGER, 
	max_concurrent INTEGER, 
	votes INTEGER, 
	chunk_size INTEGER, 
	is_analyzer BOOLEAN, 
	is_verifier BOOLEAN, 
	analysis_prompt_template TEXT, 
	verification_prompt_template TEXT, is_cleanup BOOLEAN DEFAULT 0, is_chat BOOLEAN DEFAULT 0, 
	PRIMARY KEY (id), 
	UNIQUE (name)
);

CREATE TABLE "mr_reviews" (
    id INTEGER NOT NULL PRIMARY KEY,
    watcher_id INTEGER,
    gitlab_repo_id INTEGER,
    mr_iid INTEGER NOT NULL,
    mr_title VARCHAR,
    mr_url VARCHAR,
    mr_author VARCHAR,
    source_branch VARCHAR,
    target_branch VARCHAR,
    status VARCHAR,
    files_reviewed INTEGER DEFAULT 0,
    diff_findings JSON,
    diff_summary TEXT,
    diff_reviewed_at DATETIME,
    scan_id INTEGER,
    scan_started_at DATETIME,
    scan_completed_at DATETIME,
    generated_comments JSON,
    comments_posted JSON,
    approval_status VARCHAR,
    post_comments BOOLEAN DEFAULT 0,
    last_error VARCHAR,
    created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
    updated_at DATETIME, provider VARCHAR DEFAULT 'gitlab', github_repo_id INTEGER,
    FOREIGN KEY(watcher_id) REFERENCES repo_watchers (id),
    FOREIGN KEY(gitlab_repo_id) REFERENCES gitlab_repos (id),
    FOREIGN KEY(scan_id) REFERENCES scans (id)
);

CREATE TABLE profile_agent_models (
	id INTEGER NOT NULL, 
	profile_id INTEGER NOT NULL, 
	model_id INTEGER NOT NULL, 
	enabled BOOLEAN, 
	created_at DATETIME, 
	PRIMARY KEY (id), 
	CONSTRAINT uq_profile_agent_model UNIQUE (profile_id, model_id), 
	FOREIGN KEY(profile_id) REFERENCES scan_profiles (id) ON DELETE CASCADE, 
	FOREIGN KEY(model_id) REFERENCES model_configs (id) ON DELETE CASCADE
);

CREATE TABLE profile_analyzers (
	id INTEGER NOT NULL, 
	profile_id INTEGER, 
	name VARCHAR, 
	description TEXT, 
	model_id INTEGER, 
	prompt_template TEXT, 
	file_filter VARCHAR, 
	language_filter JSON, 
	role VARCHAR, 
	run_order INTEGER, 
	enabled BOOLEAN, 
	stop_on_findings BOOLEAN, 
	min_severity_to_report VARCHAR, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, chunk_size INTEGER DEFAULT 6000, 
	PRIMARY KEY (id), 
	FOREIGN KEY(profile_id) REFERENCES scan_profiles (id), 
	FOREIGN KEY(model_id) REFERENCES model_configs (id)
);

CREATE TABLE profile_verifiers (
	id INTEGER NOT NULL, 
	profile_id INTEGER, 
	name VARCHAR, 
	description TEXT, 
	model_id INTEGER NOT NULL, 
	prompt_template TEXT, 
	output_mode VARCHAR, 
	json_schema TEXT, 
	vote_weight FLOAT, 
	min_confidence INTEGER, 
	run_order INTEGER, 
	enabled BOOLEAN, 
	created_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(profile_id) REFERENCES scan_profiles (id), 
	FOREIGN KEY(model_id) REFERENCES model_configs (id)
);

CREATE TABLE repo_watchers (
	id INTEGER NOT NULL, 
	name VARCHAR NOT NULL, 
	gitlab_url VARCHAR NOT NULL, 
	gitlab_token VARCHAR, 
	project_id VARCHAR NOT NULL, 
	branch_filter VARCHAR, 
	label_filter VARCHAR, 
	scan_profile_id INTEGER, 
	review_model_id INTEGER, 
	webhook_id INTEGER, 
	status VARCHAR, 
	enabled BOOLEAN, 
	poll_interval INTEGER, 
	post_comments BOOLEAN, 
	last_check DATETIME, 
	last_error VARCHAR, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	updated_at DATETIME, gitlab_repo_id INTEGER REFERENCES gitlab_repos(id), provider VARCHAR DEFAULT 'gitlab', github_repo_id INTEGER, github_url VARCHAR DEFAULT 'https://api.github.com', github_token VARCHAR, github_owner VARCHAR, github_repo_name VARCHAR, max_files_to_review INTEGER DEFAULT 100, mr_lookback_days INTEGER DEFAULT 7, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_profile_id) REFERENCES scan_profiles (id), 
	FOREIGN KEY(review_model_id) REFERENCES model_configs (id), 
	FOREIGN KEY(webhook_id) REFERENCES webhook_configs (id)
);

CREATE TABLE scan_configs (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	analysis_mode VARCHAR, 
	primary_analyzer_id INTEGER, 
	scope VARCHAR, 
	multi_model_scan BOOLEAN, 
	min_votes_to_verify INTEGER, 
	deduplicate_drafts BOOLEAN, 
	scanner_concurrency INTEGER, 
	verifier_concurrency INTEGER, 
	enricher_concurrency INTEGER, 
	batch_size INTEGER, 
	chunk_size INTEGER, 
	chunk_strategy VARCHAR, 
	file_filter VARCHAR, profile_id INTEGER REFERENCES scan_profiles(id), 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id), 
	FOREIGN KEY(primary_analyzer_id) REFERENCES model_configs (id)
);

CREATE TABLE scan_error_logs (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	chunk_id INTEGER, 
	phase VARCHAR, 
	error_type VARCHAR, 
	error_message TEXT, 
	retry_count INTEGER, 
	model_name VARCHAR, 
	file_path VARCHAR, 
	chunk_index INTEGER, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	resolved_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id), 
	FOREIGN KEY(chunk_id) REFERENCES scan_file_chunks (id)
);

CREATE TABLE scan_file_chunks (
	id INTEGER NOT NULL, 
	scan_file_id INTEGER, 
	chunk_index INTEGER, 
	chunk_type VARCHAR, 
	symbol_name VARCHAR, 
	start_line INTEGER, 
	end_line INTEGER, 
	content_hash VARCHAR, 
	status VARCHAR, 
	retry_count INTEGER, 
	last_error TEXT, 
	next_retry_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_file_id) REFERENCES scan_files (id)
);

CREATE TABLE scan_files (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	file_path VARCHAR, 
	file_hash VARCHAR, 
	risk_level VARCHAR, 
	status VARCHAR, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);

CREATE TABLE scan_metrics (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	total_chunks INTEGER, 
	avg_chunk_tokens FLOAT, 
	min_chunk_tokens INTEGER, 
	max_chunk_tokens INTEGER, 
	chunk_size_setting INTEGER, 
	total_time_ms FLOAT, 
	ingestion_time_ms FLOAT, 
	indexing_time_ms FLOAT, 
	chunking_time_ms FLOAT, 
	analysis_time_ms FLOAT, 
	total_tokens_in INTEGER, 
	total_tokens_out INTEGER, 
	tokens_per_second FLOAT, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);

CREATE TABLE scan_profiles (
	id INTEGER NOT NULL, 
	name VARCHAR, 
	description TEXT, 
	is_default BOOLEAN, 
	chunk_size INTEGER, 
	chunk_strategy VARCHAR, 
	enabled BOOLEAN, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	updated_at DATETIME, 
	PRIMARY KEY (id)
);

CREATE TABLE scans (
	id INTEGER NOT NULL, 
	target_url VARCHAR, 
	status VARCHAR, 
	consensus_enabled BOOLEAN, 
	logs TEXT, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	updated_at DATETIME, 
	PRIMARY KEY (id)
);

CREATE TABLE sqlite_sequence(name,seq);

CREATE TABLE static_rules (
	id INTEGER NOT NULL, 
	name VARCHAR, 
	description TEXT, 
	pattern VARCHAR, 
	languages JSON, 
	cwe_id VARCHAR, 
	vulnerability_type VARCHAR, 
	severity VARCHAR, 
	is_definite BOOLEAN, 
	requires_llm_verification BOOLEAN, 
	enabled BOOLEAN, 
	built_in BOOLEAN, 
	match_count INTEGER, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	updated_at DATETIME, 
	PRIMARY KEY (id)
);

CREATE TABLE symbol_references (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	symbol_id INTEGER, 
	from_file VARCHAR, 
	from_line INTEGER, 
	from_symbol_id INTEGER, 
	reference_type VARCHAR, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id), 
	FOREIGN KEY(symbol_id) REFERENCES symbols (id), 
	FOREIGN KEY(from_symbol_id) REFERENCES symbols (id)
);

CREATE TABLE symbols (
	id INTEGER NOT NULL, 
	scan_id INTEGER, 
	name VARCHAR, 
	qualified_name VARCHAR, 
	symbol_type VARCHAR, 
	file_path VARCHAR, 
	start_line INTEGER, 
	end_line INTEGER, 
	symbol_metadata JSON, 
	PRIMARY KEY (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);

CREATE TABLE tuning_prompt_templates (
        id INTEGER PRIMARY KEY,
        name VARCHAR NOT NULL UNIQUE,
        description TEXT,
        template TEXT NOT NULL,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP
    );

CREATE TABLE tuning_results (
        id INTEGER PRIMARY KEY,
        run_id INTEGER NOT NULL REFERENCES tuning_runs(id),
        model_id INTEGER NOT NULL REFERENCES model_configs(id),
        model_name VARCHAR NOT NULL,
        prompt_id INTEGER NOT NULL REFERENCES tuning_prompt_templates(id),
        test_case_id INTEGER NOT NULL REFERENCES tuning_test_cases(id),
        full_prompt TEXT NOT NULL,
        raw_response TEXT,
        predicted_vote VARCHAR,
        confidence INTEGER,
        reasoning TEXT,
        correct BOOLEAN DEFAULT 0,
        parse_success BOOLEAN DEFAULT 1,
        parse_error TEXT,
        duration_ms REAL,
        tokens_in INTEGER,
        tokens_out INTEGER,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
    );

CREATE TABLE tuning_runs (
        id INTEGER PRIMARY KEY,
        name VARCHAR,
        description TEXT,
        model_ids JSON NOT NULL,
        prompt_ids JSON NOT NULL,
        test_case_ids JSON NOT NULL,
        concurrency INTEGER DEFAULT 4,
        status VARCHAR DEFAULT 'running',
        total_tests INTEGER DEFAULT 0,
        completed_tests INTEGER DEFAULT 0,
        total_duration_ms REAL,
        error_message TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        completed_at TIMESTAMP
    );

CREATE TABLE tuning_test_cases (
        id INTEGER PRIMARY KEY,
        name VARCHAR NOT NULL UNIQUE,
        verdict VARCHAR NOT NULL,
        draft_finding_id INTEGER REFERENCES draft_findings(id),
        issue TEXT,
        file VARCHAR,
        code TEXT,
        claim TEXT,
        created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
        updated_at TIMESTAMP
    );

CREATE TABLE user_sessions (
	id INTEGER NOT NULL, 
	user_id INTEGER NOT NULL, 
	token VARCHAR(64) NOT NULL, 
	expires_at DATETIME NOT NULL, 
	created_at DATETIME, 
	ip_address VARCHAR, 
	user_agent VARCHAR, 
	PRIMARY KEY (id), 
	FOREIGN KEY(user_id) REFERENCES users (id) ON DELETE CASCADE
);

CREATE TABLE users (
	id INTEGER NOT NULL, 
	email VARCHAR NOT NULL, 
	display_name VARCHAR NOT NULL, 
	hashed_password VARCHAR NOT NULL, 
	role VARCHAR, 
	status VARCHAR, 
	created_at DATETIME, 
	approved_at DATETIME, 
	approved_by_id INTEGER, 
	last_login DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(approved_by_id) REFERENCES users (id)
);

CREATE TABLE verification_votes (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        scan_id INTEGER,
        draft_finding_id INTEGER,
        model_name VARCHAR,
        verifier_id INTEGER,
        decision VARCHAR,
        confidence INTEGER,
        reasoning TEXT,
        attack_scenario TEXT,
        raw_response TEXT,
        parse_success BOOLEAN,
        format_detected VARCHAR,
        vote_weight FLOAT,
        created_at DATETIME,
        FOREIGN KEY(scan_id) REFERENCES scans(id),
        FOREIGN KEY(draft_finding_id) REFERENCES draft_findings(id),
        FOREIGN KEY(verifier_id) REFERENCES profile_verifiers(id)
    );

CREATE TABLE verified_findings (
	id INTEGER NOT NULL, 
	draft_id INTEGER, 
	scan_id INTEGER, 
	title VARCHAR, 
	confidence INTEGER, 
	attack_vector TEXT, 
	data_flow TEXT, 
	adjusted_severity VARCHAR, 
	status VARCHAR, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	PRIMARY KEY (id), 
	FOREIGN KEY(draft_id) REFERENCES draft_findings (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);

CREATE TABLE vulnerability_categories (
	id INTEGER NOT NULL, 
	name VARCHAR, 
	cwe_id VARCHAR, 
	short_name VARCHAR, 
	description TEXT, 
	keywords JSON, 
	usage_count INTEGER, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	PRIMARY KEY (id)
);

CREATE TABLE webhook_configs (
	id INTEGER NOT NULL, 
	name VARCHAR NOT NULL, 
	url VARCHAR NOT NULL, 
	secret VARCHAR, 
	events JSON, 
	min_severity VARCHAR, 
	enabled BOOLEAN, 
	last_triggered DATETIME, 
	trigger_count INTEGER, 
	last_error VARCHAR, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	updated_at DATETIME, 
	PRIMARY KEY (id)
);

CREATE TABLE webhook_delivery_logs (
	id INTEGER NOT NULL, 
	webhook_id INTEGER, 
	event_type VARCHAR, 
	scan_id INTEGER, 
	finding_id INTEGER, 
	payload JSON, 
	status VARCHAR, 
	status_code INTEGER, 
	response_body TEXT, 
	error_message VARCHAR, 
	attempt_count INTEGER, 
	created_at DATETIME DEFAULT CURRENT_TIMESTAMP, 
	delivered_at DATETIME, 
	PRIMARY KEY (id), 
	FOREIGN KEY(webhook_id) REFERENCES webhook_configs (id), 
	FOREIGN KEY(scan_id) REFERENCES scans (id)
);

-- ==========================================
-- INDEXES
-- ==========================================

CREATE INDEX ix_scans_id ON scans (id);
CREATE INDEX ix_vulnerability_categories_cwe_id ON vulnerability_categories (cwe_id);
CREATE UNIQUE INDEX ix_vulnerability_categories_name ON vulnerability_categories (name);
CREATE INDEX ix_static_rules_name ON static_rules (name);
CREATE INDEX ix_scan_files_scan_id ON scan_files (scan_id);
CREATE INDEX ix_scan_files_file_path ON scan_files (file_path);
CREATE INDEX ix_symbols_file_path ON symbols (file_path);
CREATE INDEX ix_symbols_scan_id ON symbols (scan_id);
CREATE INDEX ix_symbols_name ON symbols (name);
CREATE INDEX ix_symbols_qualified_name ON symbols (qualified_name);
CREATE INDEX ix_import_relations_importer_file ON import_relations (importer_file);
CREATE INDEX ix_import_relations_scan_id ON import_relations (scan_id);
CREATE INDEX ix_llm_call_metrics_phase ON llm_call_metrics (phase);
CREATE INDEX ix_llm_call_metrics_model_name ON llm_call_metrics (model_name);
CREATE INDEX ix_llm_call_metrics_scan_id ON llm_call_metrics (scan_id);
CREATE UNIQUE INDEX ix_scan_metrics_scan_id ON scan_metrics (scan_id);
CREATE INDEX ix_scan_file_chunks_content_hash ON scan_file_chunks (content_hash);
CREATE INDEX ix_scan_file_chunks_scan_file_id ON scan_file_chunks (scan_file_id);
CREATE INDEX ix_symbol_references_symbol_id ON symbol_references (symbol_id);
CREATE INDEX ix_symbol_references_scan_id ON symbol_references (scan_id);
CREATE INDEX ix_draft_findings_scan_id ON draft_findings (scan_id);
CREATE INDEX ix_draft_findings_dedup_key ON draft_findings (dedup_key);
CREATE INDEX ix_scan_error_logs_phase ON scan_error_logs (phase);
CREATE INDEX ix_scan_error_logs_scan_id ON scan_error_logs (scan_id);
CREATE INDEX ix_verified_findings_scan_id ON verified_findings (scan_id);
CREATE INDEX ix_findings_id ON findings (id);
CREATE UNIQUE INDEX ix_scan_profiles_name ON scan_profiles (name);
CREATE INDEX ix_profile_analyzers_profile_id ON profile_analyzers (profile_id);
CREATE INDEX ix_webhook_delivery_logs_webhook_id ON webhook_delivery_logs (webhook_id);
CREATE INDEX ix_webhook_delivery_logs_event_type ON webhook_delivery_logs (event_type);
CREATE INDEX ix_webhook_delivery_logs_scan_id ON webhook_delivery_logs (scan_id);
CREATE INDEX ix_mr_reviews_watcher_id ON mr_reviews (watcher_id);
CREATE INDEX ix_mr_reviews_gitlab_repo_id ON mr_reviews (gitlab_repo_id);
CREATE INDEX ix_generated_fixes_id ON generated_fixes (id);
CREATE INDEX ix_verification_votes_scan_id ON verification_votes (scan_id);
CREATE INDEX ix_verification_votes_draft_finding_id ON verification_votes (draft_finding_id);
CREATE INDEX ix_verification_votes_model_name ON verification_votes (model_name);
CREATE INDEX idx_tuning_prompts_name ON tuning_prompt_templates(name);
CREATE INDEX idx_tuning_cases_name ON tuning_test_cases(name);
CREATE INDEX idx_tuning_cases_verdict ON tuning_test_cases(verdict);
CREATE INDEX idx_tuning_runs_status ON tuning_runs(status);
CREATE INDEX idx_tuning_results_run ON tuning_results(run_id);
CREATE INDEX idx_tuning_results_model ON tuning_results(model_id);
CREATE INDEX idx_tuning_results_prompt ON tuning_results(prompt_id);
CREATE INDEX idx_tuning_results_case ON tuning_results(test_case_id);
CREATE INDEX idx_tuning_results_correct ON tuning_results(correct);
CREATE UNIQUE INDEX ix_users_email ON users (email);
CREATE INDEX ix_users_id ON users (id);
CREATE INDEX ix_profile_agent_models_profile_id ON profile_agent_models (profile_id);
CREATE INDEX ix_agent_sessions_draft_finding_id ON agent_sessions (draft_finding_id);
CREATE INDEX ix_agent_sessions_status ON agent_sessions (status);
CREATE INDEX ix_agent_sessions_finding_id ON agent_sessions (finding_id);
CREATE INDEX ix_agent_sessions_scan_id ON agent_sessions (scan_id);
CREATE INDEX ix_profile_verifiers_profile_id ON profile_verifiers (profile_id);
CREATE UNIQUE INDEX ix_global_settings_key ON global_settings ("key");
CREATE INDEX idx_sessions_expires ON user_sessions (expires_at);
CREATE INDEX ix_user_sessions_id ON user_sessions (id);
CREATE UNIQUE INDEX ix_user_sessions_token ON user_sessions (token);
CREATE INDEX idx_comments_finding ON finding_comments (finding_id);
CREATE INDEX ix_finding_comments_id ON finding_comments (id);
CREATE INDEX ix_benchmark_cases_dataset_id ON benchmark_cases (dataset_id);
CREATE INDEX ix_benchmark_runs_model_id ON benchmark_runs (model_id);
CREATE INDEX ix_benchmark_runs_dataset_id ON benchmark_runs (dataset_id);
CREATE INDEX ix_benchmark_results_run_id ON benchmark_results (run_id);
CREATE INDEX ix_benchmark_results_case_id ON benchmark_results (case_id);

-- ==========================================
-- CONFIGURATION DATA
-- ==========================================

-- Table: model_configs (5 rows)
INSERT INTO model_configs (id, name, base_url, api_key, max_tokens, max_concurrent, votes, chunk_size, is_analyzer, is_verifier, analysis_prompt_template, verification_prompt_template, is_cleanup, is_chat) VALUES (1, 'gpt-oss-120b', 'https://davy.labs.lenovo.com:5000/v1', 'testkeyforchrisvp', 99000, 10, 1, 3000, 1, 1, 'Analyze this {language} code for security vulnerabilities.

=== FILE BEING ANALYZED ===
{file_name}

=== CODE TO ANALYZE (with line numbers) ===
{code}

=== OTHER FILES IN CODEBASE ===
{file_list}

=== FULL FILE CONTEXT ===
{full_file}

Code has line numbers (e.g., "  42 | code"). Use EXACT line numbers in findings.

=== CWE CLASSIFICATION RULES ===
Use the CORRECT CWE based on the SINK, not the intermediate functions:

| Sink Pattern | CWE | Name |
|--------------|-----|------|
| system(), popen(), exec*() with user data | CWE-78 | Command Injection |
| strcpy(), strcat(), sprintf(), gets() to fixed buffer | CWE-120 | Buffer Overflow |
| printf(user_data) - user string AS format | CWE-134 | Format String |
| free(ptr) then use ptr, or free twice | CWE-416/415 | Use-After-Free/Double-Free |
| SQL query with concatenated user input | CWE-89 | SQL Injection |
| file path with "../" or user-controlled path | CWE-22 | Path Traversal |
| size_t/int overflow in malloc size or loop | CWE-190 | Integer Overflow |
| hardcoded password, key, token in source | CWE-798 | Hardcoded Credentials |

=== CRITICAL CLASSIFICATION RULES ===
- If sprintf/snprintf builds a string that is THEN passed to system()/popen()/exec() â†’ CWE-78 Command Injection
- CWE-134 Format String is ONLY when user input IS the format string (e.g., printf(user_data))
- sprintf(buf, "%s", user_data) is NOT format string - the format IS fixed ("%s")
- LOOK AT THE SINK (system/printf/strcpy), not the intermediate functions

=== WHAT TO REPORT ===
- Memory corruption: buffer overflow, use-after-free, double-free
- Injection: command, SQL, format string, path traversal
- Crypto issues: hardcoded secrets, weak algorithms
- Integer issues: overflow in size calculations

=== WHAT TO SKIP ===
- Missing null checks (unless causes crash with untrusted input)
- Style issues, missing error handling
- Theoretical issues requiring unlikely conditions

=== EXAMPLES ===

 331 | strcpy(credentials, username);
 332 | strcat(credentials, password);

*DRAFT: Buffer Overflow in Credential Handling
*TYPE: CWE-120
*SEVERITY: High
*LINE: 331
*SNIPPET: strcpy(credentials, username);
*REASON: Unbounded copy of username into fixed 128-byte buffer
*END_DRAFT

 330 | snprintf(cmd, sizeof(cmd), "/bin/sh %s", user_input);
 331 | system(cmd);

*DRAFT: Command Injection via Shell Execution
*TYPE: CWE-78
*SEVERITY: Critical
*LINE: 331
*SNIPPET: system(cmd);
*REASON: User-controlled input passed to system() shell execution
*END_DRAFT

 410 | free(block);
 411 | process_data(block->data);

*DRAFT: Use-After-Free
*TYPE: CWE-416
*SEVERITY: High
*LINE: 411
*SNIPPET: process_data(block->data);
*REASON: Accessing block->data after block was freed
*END_DRAFT

 312 | log_message(user_input);  // where log_message calls printf(msg)

*DRAFT: Format String Vulnerability
*TYPE: CWE-134
*SEVERITY: High
*LINE: 312
*SNIPPET: log_message(user_input);
*REASON: User input passed as format string to printf-family function
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number
*SNIPPET: the vulnerable code
*REASON: one sentence explanation
*END_DRAFT

Report all findings. If none found: *DRAFT:NONE', 'You are verifying a potential security vulnerability.

=== FINDING TO VERIFY ===
Title: {title}
Type: {vuln_type}
Severity: {severity}
Line: {line}

Reported Code:
{snippet}

Scanner''s Reason: {reason}

=== PRE-FETCHED CONTEXT (already gathered for you) ===
{context}

=== VERIFICATION CRITERIA ===

IMPORTANT: Missing a real vulnerability is worse than a false positive, BUT low-quality findings waste developer time.
Your goal is to identify EXPLOITABLE vulnerabilities while filtering out safe patterns.

=== SAFE PATTERNS TO REJECT ===

These are FALSE POSITIVES - REJECT them:
- `(size + 7) & ~7` or similar alignment - standard idiom, unexploitable
- `strncpy(dst, src, sizeof(dst) - 1)` - bounded copy, safe even without explicit null-term
- `strncpy(dst, src, sizeof(dst)); dst[sizeof(dst)-1] = ''\0'';` - bounded with null-term
- `strncpy(dst, src, N)` where N <= sizeof(dst) - size-limited is safe
- `snprintf(buf, sizeof(buf), ...)` - size-limited, safe
- `vsnprintf(buf, sizeof(buf), ...)` - size-limited, safe
- Integer overflow in display/logging only (no security impact)
- Functions with no callers and not exported (dead code)
- Missing null-termination claims when strncpy uses sizeof(dst)-1 (leaves room for null)

=== WEAKNESS PATTERNS ===

These are real but low-priority - mark as WEAKNESS:
- Theoretical overflow with no realistic attack path
- Missing null-termination where buffer is always overwritten
- Bad practice in non-security-critical code path
- DoS-only impact (no RCE, no data leak)

=== VERIFY PATTERNS ===

These are TRUE POSITIVES - VERIFY them:
- `system(user_input)` or `popen(user_input)` - command injection
- `strcpy(fixed_buf, user_input)` - unbounded copy
- `sprintf(buf, user_fmt)` where user controls format - format string
- `printf(user_str)` - format string (user string AS the format)
- `free(ptr); use(ptr);` - use-after-free
- SQL/path with concatenated user input - injection

=== DECISION GUIDE ===

VERIFY if:
1. Dangerous sink function (system, strcpy, printf with user format)
2. AND attacker data can reach it (trace the data flow)
3. AND security impact exists (RCE, memory corruption, data leak)

WEAKNESS if:
- Pattern is risky but impact is limited (DoS, info leak of non-sensitive data)
- OR requires unlikely conditions to exploit

REJECT if:
- Safe variant used (strncpy with limit, snprintf)
- OR standard safe idiom (alignment, bounded copy)
- OR no attacker-controlled input reaches the sink

=== RESPONSE ===
*VOTE: VERIFY, WEAKNESS, or REJECT
*CONFIDENCE: 0-100 (lower if uncertain)
*REASONING: [2-3 sentences explaining data flow and exploitability]
*END_VOTE', 0, 0);
INSERT INTO model_configs (id, name, base_url, api_key, max_tokens, max_concurrent, votes, chunk_size, is_analyzer, is_verifier, analysis_prompt_template, verification_prompt_template, is_cleanup, is_chat) VALUES (2, 'mistral-small', 'https://davy.labs.lenovo.com:5000/v1', 'testkeyforchrisvp', 99000, 5, 1, 3000, 0, 1, NULL, 'You are verifying a potential security vulnerability.

=== FINDING TO VERIFY ===
Title: {title}
Type: {vuln_type}
Severity: {severity}
Line: {line}

Reported Code:
{snippet}

Scanner''s Reason: {reason}

=== PRE-FETCHED CONTEXT (already gathered for you) ===
{context}

=== VERIFICATION CRITERIA ===

IMPORTANT: Missing a real vulnerability is worse than a false positive, BUT low-quality findings waste developer time.
Your goal is to identify EXPLOITABLE vulnerabilities while filtering out safe patterns.

=== SAFE PATTERNS TO REJECT ===

These are FALSE POSITIVES - REJECT them:
- `(size + 7) & ~7` or similar alignment - standard idiom, unexploitable
- `strncpy(dst, src, sizeof(dst) - 1)` - bounded copy, safe even without explicit null-term
- `strncpy(dst, src, sizeof(dst)); dst[sizeof(dst)-1] = ''\0'';` - bounded with null-term
- `strncpy(dst, src, N)` where N <= sizeof(dst) - size-limited is safe
- `snprintf(buf, sizeof(buf), ...)` - size-limited, safe
- `vsnprintf(buf, sizeof(buf), ...)` - size-limited, safe
- Integer overflow in display/logging only (no security impact)
- Functions with no callers and not exported (dead code)
- Missing null-termination claims when strncpy uses sizeof(dst)-1 (leaves room for null)

=== WEAKNESS PATTERNS ===

These are real but low-priority - mark as WEAKNESS:
- Theoretical overflow with no realistic attack path
- Missing null-termination where buffer is always overwritten
- Bad practice in non-security-critical code path
- DoS-only impact (no RCE, no data leak)

=== VERIFY PATTERNS ===

These are TRUE POSITIVES - VERIFY them:
- `system(user_input)` or `popen(user_input)` - command injection
- `strcpy(fixed_buf, user_input)` - unbounded copy
- `sprintf(buf, user_fmt)` where user controls format - format string
- `printf(user_str)` - format string (user string AS the format)
- `free(ptr); use(ptr);` - use-after-free
- SQL/path with concatenated user input - injection

=== DECISION GUIDE ===

VERIFY if:
1. Dangerous sink function (system, strcpy, printf with user format)
2. AND attacker data can reach it (trace the data flow)
3. AND security impact exists (RCE, memory corruption, data leak)

WEAKNESS if:
- Pattern is risky but impact is limited (DoS, info leak of non-sensitive data)
- OR requires unlikely conditions to exploit

REJECT if:
- Safe variant used (strncpy with limit, snprintf)
- OR standard safe idiom (alignment, bounded copy)
- OR no attacker-controlled input reaches the sink

=== RESPONSE ===
*VOTE: VERIFY, WEAKNESS, or REJECT
*CONFIDENCE: 0-100 (lower if uncertain)
*REASONING: [2-3 sentences explaining data flow and exploitability]
*END_VOTE', 0, 0);
INSERT INTO model_configs (id, name, base_url, api_key, max_tokens, max_concurrent, votes, chunk_size, is_analyzer, is_verifier, analysis_prompt_template, verification_prompt_template, is_cleanup, is_chat) VALUES (3, 'llama3.3-70b-instruct', 'https://davy.labs.lenovo.com:5000/v1', 'testkeyforchrisvp', 99000, 5, 1, 3000, 0, 1, NULL, 'You are verifying a potential security vulnerability.

=== FINDING TO VERIFY ===
Title: {title}
Type: {vuln_type}
Severity: {severity}
Line: {line}

Reported Code:
{snippet}

Scanner''s Reason: {reason}

=== PRE-FETCHED CONTEXT (already gathered for you) ===
{context}

=== VERIFICATION CRITERIA ===

IMPORTANT: Missing a real vulnerability is worse than a false positive, BUT low-quality findings waste developer time.
Your goal is to identify EXPLOITABLE vulnerabilities while filtering out safe patterns.

=== SAFE PATTERNS TO REJECT ===

These are FALSE POSITIVES - REJECT them:
- `(size + 7) & ~7` or similar alignment - standard idiom, unexploitable
- `strncpy(dst, src, sizeof(dst) - 1)` - bounded copy, safe even without explicit null-term
- `strncpy(dst, src, sizeof(dst)); dst[sizeof(dst)-1] = ''\0'';` - bounded with null-term
- `strncpy(dst, src, N)` where N <= sizeof(dst) - size-limited is safe
- `snprintf(buf, sizeof(buf), ...)` - size-limited, safe
- `vsnprintf(buf, sizeof(buf), ...)` - size-limited, safe
- Integer overflow in display/logging only (no security impact)
- Functions with no callers and not exported (dead code)
- Missing null-termination claims when strncpy uses sizeof(dst)-1 (leaves room for null)

=== WEAKNESS PATTERNS ===

These are real but low-priority - mark as WEAKNESS:
- Theoretical overflow with no realistic attack path
- Missing null-termination where buffer is always overwritten
- Bad practice in non-security-critical code path
- DoS-only impact (no RCE, no data leak)

=== VERIFY PATTERNS ===

These are TRUE POSITIVES - VERIFY them:
- `system(user_input)` or `popen(user_input)` - command injection
- `strcpy(fixed_buf, user_input)` - unbounded copy
- `sprintf(buf, user_fmt)` where user controls format - format string
- `printf(user_str)` - format string (user string AS the format)
- `free(ptr); use(ptr);` - use-after-free
- SQL/path with concatenated user input - injection

=== DECISION GUIDE ===

VERIFY if:
1. Dangerous sink function (system, strcpy, printf with user format)
2. AND attacker data can reach it (trace the data flow)
3. AND security impact exists (RCE, memory corruption, data leak)

WEAKNESS if:
- Pattern is risky but impact is limited (DoS, info leak of non-sensitive data)
- OR requires unlikely conditions to exploit

REJECT if:
- Safe variant used (strncpy with limit, snprintf)
- OR standard safe idiom (alignment, bounded copy)
- OR no attacker-controlled input reaches the sink

=== RESPONSE ===
*VOTE: VERIFY, WEAKNESS, or REJECT
*CONFIDENCE: 0-100 (lower if uncertain)
*REASONING: [2-3 sentences explaining data flow and exploitability]
*END_VOTE', 0, 1);
INSERT INTO model_configs (id, name, base_url, api_key, max_tokens, max_concurrent, votes, chunk_size, is_analyzer, is_verifier, analysis_prompt_template, verification_prompt_template, is_cleanup, is_chat) VALUES (4, 'gemma-3-27b-it', 'https://davy.labs.lenovo.com:5000/v1', 'testkeyforchrisvp', 99000, 5, 1, 3000, 0, 1, NULL, 'You are verifying a potential security vulnerability.

=== FINDING TO VERIFY ===
Title: {title}
Type: {vuln_type}
Severity: {severity}
Line: {line}

Reported Code:
{snippet}

Scanner''s Reason: {reason}

=== PRE-FETCHED CONTEXT (already gathered for you) ===
{context}

=== VERIFICATION CRITERIA ===

IMPORTANT: Missing a real vulnerability is worse than a false positive, BUT low-quality findings waste developer time.
Your goal is to identify EXPLOITABLE vulnerabilities while filtering out safe patterns.

=== SAFE PATTERNS TO REJECT ===

These are FALSE POSITIVES - REJECT them:
- `(size + 7) & ~7` or similar alignment - standard idiom, unexploitable
- `strncpy(dst, src, sizeof(dst) - 1)` - bounded copy, safe even without explicit null-term
- `strncpy(dst, src, sizeof(dst)); dst[sizeof(dst)-1] = ''\0'';` - bounded with null-term
- `strncpy(dst, src, N)` where N <= sizeof(dst) - size-limited is safe
- `snprintf(buf, sizeof(buf), ...)` - size-limited, safe
- `vsnprintf(buf, sizeof(buf), ...)` - size-limited, safe
- Integer overflow in display/logging only (no security impact)
- Functions with no callers and not exported (dead code)
- Missing null-termination claims when strncpy uses sizeof(dst)-1 (leaves room for null)

=== WEAKNESS PATTERNS ===

These are real but low-priority - mark as WEAKNESS:
- Theoretical overflow with no realistic attack path
- Missing null-termination where buffer is always overwritten
- Bad practice in non-security-critical code path
- DoS-only impact (no RCE, no data leak)

=== VERIFY PATTERNS ===

These are TRUE POSITIVES - VERIFY them:
- `system(user_input)` or `popen(user_input)` - command injection
- `strcpy(fixed_buf, user_input)` - unbounded copy
- `sprintf(buf, user_fmt)` where user controls format - format string
- `printf(user_str)` - format string (user string AS the format)
- `free(ptr); use(ptr);` - use-after-free
- SQL/path with concatenated user input - injection

=== DECISION GUIDE ===

VERIFY if:
1. Dangerous sink function (system, strcpy, printf with user format)
2. AND attacker data can reach it (trace the data flow)
3. AND security impact exists (RCE, memory corruption, data leak)

WEAKNESS if:
- Pattern is risky but impact is limited (DoS, info leak of non-sensitive data)
- OR requires unlikely conditions to exploit

REJECT if:
- Safe variant used (strncpy with limit, snprintf)
- OR standard safe idiom (alignment, bounded copy)
- OR no attacker-controlled input reaches the sink

=== RESPONSE ===
*VOTE: VERIFY, WEAKNESS, or REJECT
*CONFIDENCE: 0-100 (lower if uncertain)
*REASONING: [2-3 sentences explaining data flow and exploitability]
*END_VOTE', 0, 0);
INSERT INTO model_configs (id, name, base_url, api_key, max_tokens, max_concurrent, votes, chunk_size, is_analyzer, is_verifier, analysis_prompt_template, verification_prompt_template, is_cleanup, is_chat) VALUES (5, 'phi4', 'https://davy.labs.lenovo.com:5000/v1', 'testkeyforchrisvp', 11000, 5, 1, 3000, 0, 0, 'You are a cleanup model. Reformat the following LLM response to match the expected format.', 'You are a cleanup model. Reformat the following LLM response to match the expected format.', 1, 0);

-- Table: scan_profiles (6 rows)
INSERT INTO scan_profiles (id, name, description, is_default, chunk_size, chunk_strategy, enabled, created_at, updated_at) VALUES (1, 'Quick Scan', 'Fast general security scan using smaller model', 1, 6000, 'smart', 1, '2025-11-26 04:43:41', NULL);
INSERT INTO scan_profiles (id, name, description, is_default, chunk_size, chunk_strategy, enabled, created_at, updated_at) VALUES (2, 'Deep C Audit', 'Comprehensive C/C++ security audit with memory safety and signal handler checks', 0, 8000, 'smart', 1, '2025-11-26 04:43:41', NULL);
INSERT INTO scan_profiles (id, name, description, is_default, chunk_size, chunk_strategy, enabled, created_at, updated_at) VALUES (3, 'Python Audit', 'Python-focused security scan', 0, 6000, 'smart', 1, '2025-11-26 04:43:41', NULL);
INSERT INTO scan_profiles (id, name, description, is_default, chunk_size, chunk_strategy, enabled, created_at, updated_at) VALUES (4, 'Crypto Audit', 'Focus on cryptographic weaknesses', 0, 6000, 'smart', 1, '2025-11-26 04:43:41', NULL);
INSERT INTO scan_profiles (id, name, description, is_default, chunk_size, chunk_strategy, enabled, created_at, updated_at) VALUES (5, 'CVE Hunt', 'Maximum coverage - runs all specialized analyzers', 0, 8000, 'smart', 1, '2025-11-26 04:43:41', NULL);
INSERT INTO scan_profiles (id, name, description, is_default, chunk_size, chunk_strategy, enabled, created_at, updated_at) VALUES (6, 'Test', '', 0, 6000, 'smart', 1, '2025-11-26 06:30:10', NULL);

-- Table: profile_analyzers (14 rows)
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (1, 1, 'General Security', 'General security analysis for all languages', 1, 'Analyze this {language} code for security vulnerabilities.

File: {file_path}

```{language}
{code}
```

Look for:
- Injection vulnerabilities (SQL, command, XSS, path traversal)
- Authentication and authorization issues
- Cryptographic weaknesses
- Input validation problems
- Information disclosure
- Race conditions
- Resource leaks

=== EXAMPLES ===

 42 | query = "SELECT * FROM users WHERE id = " + user_id

*DRAFT: SQL Injection via String Concatenation
*TYPE: CWE-89 SQL Injection
*SEVERITY: Critical
*LINE: 42
*SNIPPET: query = "SELECT * FROM users WHERE id = " + user_id
*REASON: User input directly concatenated into SQL query without parameterization
*END_DRAFT

 15 | os.system("rm -rf " + user_path)

*DRAFT: Command Injection via os.system
*TYPE: CWE-78 OS Command Injection
*SEVERITY: Critical
*LINE: 15
*SNIPPET: os.system("rm -rf " + user_path)
*REASON: User-controlled path passed to shell command without sanitization
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.c,*.h,*.cpp,*.py', NULL, 'analyzer', 1, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (2, 2, 'General Security', NULL, 1, 'Analyze this {language} code for security vulnerabilities.

File: {file_path}

```{language}
{code}
```

Look for:
- Injection vulnerabilities (SQL, command, XSS, path traversal)
- Authentication and authorization issues
- Cryptographic weaknesses
- Input validation problems
- Information disclosure
- Race conditions
- Resource leaks

=== EXAMPLES ===

 42 | query = "SELECT * FROM users WHERE id = " + user_id

*DRAFT: SQL Injection via String Concatenation
*TYPE: CWE-89 SQL Injection
*SEVERITY: Critical
*LINE: 42
*SNIPPET: query = "SELECT * FROM users WHERE id = " + user_id
*REASON: User input directly concatenated into SQL query without parameterization
*END_DRAFT

 15 | os.system("rm -rf " + user_path)

*DRAFT: Command Injection via os.system
*TYPE: CWE-78 OS Command Injection
*SEVERITY: Critical
*LINE: 15
*SNIPPET: os.system("rm -rf " + user_path)
*REASON: User-controlled path passed to shell command without sanitization
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', NULL, NULL, 'analyzer', 1, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (3, 2, 'C Memory Safety', 'Deep analysis of memory safety issues', 1, 'Analyze this C/C++ code for memory safety vulnerabilities.

File: {file_path}

```c
{code}
```

Focus specifically on:
- Buffer overflows (stack and heap)
- Use-after-free vulnerabilities
- Double-free conditions
- Null pointer dereferences
- Integer overflows leading to buffer issues
- Format string vulnerabilities
- Uninitialized memory usage
- Out-of-bounds reads/writes
- Memory leaks in error paths

=== EXAMPLES ===

 331 | strcpy(credentials, username);
 332 | strcat(credentials, password);

*DRAFT: Buffer Overflow in Credential Handling
*TYPE: CWE-120 Buffer Overflow
*SEVERITY: High
*LINE: 331
*SNIPPET: strcpy(credentials, username);
*REASON: Unbounded copy of username into fixed-size buffer without length check
*END_DRAFT

 410 | free(block);
 411 | process_data(block->data);

*DRAFT: Use-After-Free Memory Access
*TYPE: CWE-416 Use After Free
*SEVERITY: High
*LINE: 411
*SNIPPET: process_data(block->data);
*REASON: Accessing block->data after block was freed on previous line
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.c,*.h,*.cpp,*.cc,*.cxx', '["c", "cpp"]', 'analyzer', 2, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (4, 2, 'Signal Handler Audit', 'Detect async-signal-unsafe calls in signal handlers (CVE-2024-6387 pattern)', 1, 'Analyze this C/C++ code for signal handler safety issues.

File: {file_path}

```c
{code}
```

CRITICAL: Look for signal handlers that call async-signal-UNSAFE functions.

Async-signal-UNSAFE functions include (but not limited to):
- printf, fprintf, sprintf, snprintf, vprintf (and variants)
- malloc, free, realloc, calloc
- syslog, openlog, closelog
- exit (use _exit instead)
- pthread functions
- stdio functions (fopen, fclose, fread, fwrite, etc.)
- string functions that allocate (strdup, etc.)
- Any function that acquires locks or uses global/static state

Signal handlers should ONLY call async-signal-safe functions like:
- _exit, _Exit
- write (not printf!)
- signal, sigaction
- Simple variable assignments to volatile sig_atomic_t

Race condition pattern to detect:
1. Signal handler registered with signal() or sigaction()
2. Handler calls any async-signal-unsafe function
3. This creates exploitable race condition (potential RCE)

=== EXAMPLE ===

 100 | void sigalarm_handler(int sig) {
 101 |     syslog(LOG_WARNING, "Timeout reached");
 102 |     cleanup_connection();
 103 | }

*DRAFT: Async-Signal-Unsafe Function in Signal Handler
*TYPE: CWE-364 Signal Handler Race Condition
*SEVERITY: Critical
*LINE: 101
*SNIPPET: syslog(LOG_WARNING, "Timeout reached");
*REASON: Signal handler calls syslog() which is async-signal-unsafe, creating exploitable race condition (CVE-2024-6387 pattern)
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.c,*.h,*.cpp', '["c", "cpp"]', 'analyzer', 3, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (5, 2, 'Race Conditions', 'Detect race conditions and concurrency bugs', 1, 'Analyze this code for race conditions and concurrency vulnerabilities.

File: {file_path}

```{language}
{code}
```

Look for:
- TOCTOU (Time-of-check to time-of-use) bugs
- Unprotected shared state access
- Missing synchronization primitives
- Deadlock potential
- Signal handler races (async-signal-unsafe calls)
- File system races (symlink attacks, temp file races)
- Double-checked locking anti-pattern
- Atomic operation assumptions on non-atomic types

=== EXAMPLES ===

 55 | if os.path.exists(filepath):
 56 |     with open(filepath, ''r'') as f:

*DRAFT: TOCTOU Race Condition
*TYPE: CWE-367 Time-of-check Time-of-use
*SEVERITY: Medium
*LINE: 55
*SNIPPET: if os.path.exists(filepath):
*REASON: File existence check and open are not atomic; file could be modified between check and use
*END_DRAFT

 120 | temp_file = "/tmp/app_" + str(random.randint(0, 1000))

*DRAFT: Predictable Temporary File Name
*TYPE: CWE-377 Insecure Temporary File
*SEVERITY: Medium
*LINE: 120
*SNIPPET: temp_file = "/tmp/app_" + str(random.randint(0, 1000))
*REASON: Predictable temp filename enables symlink attacks; use tempfile.mkstemp()
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.c,*.h,*.cpp', '["c", "cpp"]', 'analyzer', 4, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (6, 3, 'General Security', NULL, 1, 'Analyze this {language} code for security vulnerabilities.

File: {file_path}

```{language}
{code}
```

Look for:
- Injection vulnerabilities (SQL, command, XSS, path traversal)
- Authentication and authorization issues
- Cryptographic weaknesses
- Input validation problems
- Information disclosure
- Race conditions
- Resource leaks

=== EXAMPLES ===

 42 | query = "SELECT * FROM users WHERE id = " + user_id

*DRAFT: SQL Injection via String Concatenation
*TYPE: CWE-89 SQL Injection
*SEVERITY: Critical
*LINE: 42
*SNIPPET: query = "SELECT * FROM users WHERE id = " + user_id
*REASON: User input directly concatenated into SQL query without parameterization
*END_DRAFT

 15 | os.system("rm -rf " + user_path)

*DRAFT: Command Injection via os.system
*TYPE: CWE-78 OS Command Injection
*SEVERITY: Critical
*LINE: 15
*SNIPPET: os.system("rm -rf " + user_path)
*REASON: User-controlled path passed to shell command without sanitization
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', NULL, NULL, 'analyzer', 1, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (7, 3, 'Python Security', 'Python-specific vulnerability detection', 1, 'Analyze this Python code for security vulnerabilities.

File: {file_path}

```python
{code}
```

Focus on:
- SQL Injection (raw queries, f-strings in SQL)
- Command Injection (os.system, subprocess with shell=True, eval, exec)
- Path Traversal (unsanitized file paths)
- SSRF (unvalidated URLs)
- Deserialization (pickle.loads, yaml.load without Loader)
- Template Injection (Jinja2 with user input)
- Hardcoded secrets/credentials
- Insecure random (random module for crypto)
- XML vulnerabilities (XXE with lxml/xml.etree)

=== EXAMPLES ===

 25 | result = eval(user_expression)

*DRAFT: Code Injection via eval()
*TYPE: CWE-94 Code Injection
*SEVERITY: Critical
*LINE: 25
*SNIPPET: result = eval(user_expression)
*REASON: User input passed directly to eval() allows arbitrary code execution
*END_DRAFT

 88 | data = pickle.loads(request.data)

*DRAFT: Insecure Deserialization
*TYPE: CWE-502 Deserialization of Untrusted Data
*SEVERITY: Critical
*LINE: 88
*SNIPPET: data = pickle.loads(request.data)
*REASON: Deserializing untrusted data with pickle allows arbitrary code execution
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.py', '["python"]', 'analyzer', 2, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (8, 4, 'Cryptographic Audit', 'Detect weak cryptography usage', 1, 'Analyze this code for cryptographic weaknesses.

File: {file_path}

```{language}
{code}
```

Look for:
- Weak algorithms: MD5, SHA1 (for security), DES, 3DES, RC4, Blowfish
- Weak key sizes: RSA < 2048, ECC < 256, AES < 128
- ECB mode usage (deterministic encryption)
- Static/hardcoded IVs or keys
- Missing authentication (encryption without MAC/AEAD)
- Weak PRNGs for cryptographic use
- Deprecated TLS versions (< 1.2)
- Weak Diffie-Hellman groups (group1, group2)
- Certificate validation disabled
- Timing-vulnerable comparisons for secrets

=== EXAMPLES ===

 45 | hash = hashlib.md5(password.encode()).hexdigest()

*DRAFT: Weak Password Hashing with MD5
*TYPE: CWE-327 Use of Broken Crypto Algorithm
*SEVERITY: High
*LINE: 45
*SNIPPET: hash = hashlib.md5(password.encode()).hexdigest()
*REASON: MD5 is cryptographically broken; use bcrypt/scrypt/argon2 for passwords
*END_DRAFT

 72 | SECRET_KEY = "hardcoded_secret_123"

*DRAFT: Hardcoded Cryptographic Key
*TYPE: CWE-798 Hardcoded Credentials
*SEVERITY: High
*LINE: 72
*SNIPPET: SECRET_KEY = "hardcoded_secret_123"
*REASON: Cryptographic key hardcoded in source code; should use environment variables or key management
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', NULL, NULL, 'analyzer', 1, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (9, 5, 'General Security', NULL, 1, 'Analyze this {language} code for security vulnerabilities.

File: {file_path}

```{language}
{code}
```

Look for:
- Injection vulnerabilities (SQL, command, XSS, path traversal)
- Authentication and authorization issues
- Cryptographic weaknesses
- Input validation problems
- Information disclosure
- Race conditions
- Resource leaks

=== EXAMPLES ===

 42 | query = "SELECT * FROM users WHERE id = " + user_id

*DRAFT: SQL Injection via String Concatenation
*TYPE: CWE-89 SQL Injection
*SEVERITY: Critical
*LINE: 42
*SNIPPET: query = "SELECT * FROM users WHERE id = " + user_id
*REASON: User input directly concatenated into SQL query without parameterization
*END_DRAFT

 15 | os.system("rm -rf " + user_path)

*DRAFT: Command Injection via os.system
*TYPE: CWE-78 OS Command Injection
*SEVERITY: Critical
*LINE: 15
*SNIPPET: os.system("rm -rf " + user_path)
*REASON: User-controlled path passed to shell command without sanitization
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', NULL, NULL, 'analyzer', 1, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (10, 5, 'C Memory Safety', NULL, 1, 'Analyze this C/C++ code for memory safety vulnerabilities.

File: {file_path}

```c
{code}
```

Focus specifically on:
- Buffer overflows (stack and heap)
- Use-after-free vulnerabilities
- Double-free conditions
- Null pointer dereferences
- Integer overflows leading to buffer issues
- Format string vulnerabilities
- Uninitialized memory usage
- Out-of-bounds reads/writes
- Memory leaks in error paths

=== EXAMPLES ===

 331 | strcpy(credentials, username);
 332 | strcat(credentials, password);

*DRAFT: Buffer Overflow in Credential Handling
*TYPE: CWE-120 Buffer Overflow
*SEVERITY: High
*LINE: 331
*SNIPPET: strcpy(credentials, username);
*REASON: Unbounded copy of username into fixed-size buffer without length check
*END_DRAFT

 410 | free(block);
 411 | process_data(block->data);

*DRAFT: Use-After-Free Memory Access
*TYPE: CWE-416 Use After Free
*SEVERITY: High
*LINE: 411
*SNIPPET: process_data(block->data);
*REASON: Accessing block->data after block was freed on previous line
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.c,*.h,*.cpp,*.cc', NULL, 'analyzer', 2, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (11, 5, 'Signal Handler Audit', NULL, 1, 'Analyze this C/C++ code for signal handler safety issues.

File: {file_path}

```c
{code}
```

CRITICAL: Look for signal handlers that call async-signal-UNSAFE functions.

Async-signal-UNSAFE functions include (but not limited to):
- printf, fprintf, sprintf, snprintf, vprintf (and variants)
- malloc, free, realloc, calloc
- syslog, openlog, closelog
- exit (use _exit instead)
- pthread functions
- stdio functions (fopen, fclose, fread, fwrite, etc.)
- string functions that allocate (strdup, etc.)
- Any function that acquires locks or uses global/static state

Signal handlers should ONLY call async-signal-safe functions like:
- _exit, _Exit
- write (not printf!)
- signal, sigaction
- Simple variable assignments to volatile sig_atomic_t

Race condition pattern to detect:
1. Signal handler registered with signal() or sigaction()
2. Handler calls any async-signal-unsafe function
3. This creates exploitable race condition (potential RCE)

=== EXAMPLE ===

 100 | void sigalarm_handler(int sig) {
 101 |     syslog(LOG_WARNING, "Timeout reached");
 102 |     cleanup_connection();
 103 | }

*DRAFT: Async-Signal-Unsafe Function in Signal Handler
*TYPE: CWE-364 Signal Handler Race Condition
*SEVERITY: Critical
*LINE: 101
*SNIPPET: syslog(LOG_WARNING, "Timeout reached");
*REASON: Signal handler calls syslog() which is async-signal-unsafe, creating exploitable race condition (CVE-2024-6387 pattern)
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.c,*.h,*.cpp', NULL, 'analyzer', 3, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (12, 5, 'Race Conditions', NULL, 1, 'Analyze this code for race conditions and concurrency vulnerabilities.

File: {file_path}

```{language}
{code}
```

Look for:
- TOCTOU (Time-of-check to time-of-use) bugs
- Unprotected shared state access
- Missing synchronization primitives
- Deadlock potential
- Signal handler races (async-signal-unsafe calls)
- File system races (symlink attacks, temp file races)
- Double-checked locking anti-pattern
- Atomic operation assumptions on non-atomic types

=== EXAMPLES ===

 55 | if os.path.exists(filepath):
 56 |     with open(filepath, ''r'') as f:

*DRAFT: TOCTOU Race Condition
*TYPE: CWE-367 Time-of-check Time-of-use
*SEVERITY: Medium
*LINE: 55
*SNIPPET: if os.path.exists(filepath):
*REASON: File existence check and open are not atomic; file could be modified between check and use
*END_DRAFT

 120 | temp_file = "/tmp/app_" + str(random.randint(0, 1000))

*DRAFT: Predictable Temporary File Name
*TYPE: CWE-377 Insecure Temporary File
*SEVERITY: Medium
*LINE: 120
*SNIPPET: temp_file = "/tmp/app_" + str(random.randint(0, 1000))
*REASON: Predictable temp filename enables symlink attacks; use tempfile.mkstemp()
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', NULL, NULL, 'analyzer', 4, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (13, 5, 'Cryptographic Audit', NULL, 1, 'Analyze this code for cryptographic weaknesses.

File: {file_path}

```{language}
{code}
```

Look for:
- Weak algorithms: MD5, SHA1 (for security), DES, 3DES, RC4, Blowfish
- Weak key sizes: RSA < 2048, ECC < 256, AES < 128
- ECB mode usage (deterministic encryption)
- Static/hardcoded IVs or keys
- Missing authentication (encryption without MAC/AEAD)
- Weak PRNGs for cryptographic use
- Deprecated TLS versions (< 1.2)
- Weak Diffie-Hellman groups (group1, group2)
- Certificate validation disabled
- Timing-vulnerable comparisons for secrets

=== EXAMPLES ===

 45 | hash = hashlib.md5(password.encode()).hexdigest()

*DRAFT: Weak Password Hashing with MD5
*TYPE: CWE-327 Use of Broken Crypto Algorithm
*SEVERITY: High
*LINE: 45
*SNIPPET: hash = hashlib.md5(password.encode()).hexdigest()
*REASON: MD5 is cryptographically broken; use bcrypt/scrypt/argon2 for passwords
*END_DRAFT

 72 | SECRET_KEY = "hardcoded_secret_123"

*DRAFT: Hardcoded Cryptographic Key
*TYPE: CWE-798 Hardcoded Credentials
*SEVERITY: High
*LINE: 72
*SNIPPET: SECRET_KEY = "hardcoded_secret_123"
*REASON: Cryptographic key hardcoded in source code; should use environment variables or key management
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', NULL, NULL, 'analyzer', 5, 1, 0, NULL, '2025-11-26 04:43:41', 6000);
INSERT INTO profile_analyzers (id, profile_id, name, description, model_id, prompt_template, file_filter, language_filter, role, run_order, enabled, stop_on_findings, min_severity_to_report, created_at, chunk_size) VALUES (14, 5, 'Python Security', NULL, 1, 'Analyze this Python code for security vulnerabilities.

File: {file_path}

```python
{code}
```

Focus on:
- SQL Injection (raw queries, f-strings in SQL)
- Command Injection (os.system, subprocess with shell=True, eval, exec)
- Path Traversal (unsanitized file paths)
- SSRF (unvalidated URLs)
- Deserialization (pickle.loads, yaml.load without Loader)
- Template Injection (Jinja2 with user input)
- Hardcoded secrets/credentials
- Insecure random (random module for crypto)
- XML vulnerabilities (XXE with lxml/xml.etree)

=== EXAMPLES ===

 25 | result = eval(user_expression)

*DRAFT: Code Injection via eval()
*TYPE: CWE-94 Code Injection
*SEVERITY: Critical
*LINE: 25
*SNIPPET: result = eval(user_expression)
*REASON: User input passed directly to eval() allows arbitrary code execution
*END_DRAFT

 88 | data = pickle.loads(request.data)

*DRAFT: Insecure Deserialization
*TYPE: CWE-502 Deserialization of Untrusted Data
*SEVERITY: Critical
*LINE: 88
*SNIPPET: data = pickle.loads(request.data)
*REASON: Deserializing untrusted data with pickle allows arbitrary code execution
*END_DRAFT

=== OUTPUT FORMAT ===
*DRAFT: descriptive title
*TYPE: CWE-XXX or vulnerability category
*SEVERITY: Critical/High/Medium/Low
*LINE: exact line number from the code
*SNIPPET: the vulnerable code
*REASON: one sentence explanation of why this is vulnerable
*END_DRAFT

Report each finding separately. If no vulnerabilities found: *DRAFT:NONE
', '*.py', NULL, 'analyzer', 6, 1, 0, NULL, '2025-11-26 04:43:41', 6000);

-- Table: static_rules (24 rows)
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (1, 'gets() Buffer Overflow', 'gets() has no bounds checking - always vulnerable', 'gets\s*\(', '["c", "cpp"]', 'CWE-120', 'Buffer Overflow', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (2, 'Direct argv to system()', 'Command line argument passed directly to system()', 'system\s*\(\s*argv', '["c", "cpp"]', 'CWE-78', 'Command Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (3, 'strcpy from argv', 'Unbounded copy from command line argument', 'strcpy\s*\([^,]+,\s*argv', '["c", "cpp"]', 'CWE-120', 'Buffer Overflow', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (4, 'strcat from argv', 'Unbounded concatenation from command line argument', 'strcat\s*\([^,]+,\s*argv', '["c", "cpp"]', 'CWE-120', 'Buffer Overflow', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (5, 'scanf %s without width', 'scanf %s without width limit allows buffer overflow', 'scanf\s*\(\s*"%s"', '["c", "cpp"]', 'CWE-120', 'Buffer Overflow', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (6, 'sprintf building system command', 'sprintf builds string passed to system() - command injection', 'sprintf\s*\([^;]+\);\s*\n?\s*system\s*\(', '["c", "cpp"]', 'CWE-78', 'Command Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (7, 'snprintf building system command', 'snprintf builds string passed to system() - command injection', 'snprintf\s*\([^;]+\);\s*\n?\s*system\s*\(', '["c", "cpp"]', 'CWE-78', 'Command Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (8, 'printf with variable format', 'printf with variable as format string', 'printf\s*\(\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\)', '["c", "cpp"]', 'CWE-134', 'Format String', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (9, 'fprintf with variable format', 'fprintf with variable as format string', 'fprintf\s*\([^,]+,\s*[a-zA-Z_][a-zA-Z0-9_]*\s*\)', '["c", "cpp"]', 'CWE-134', 'Format String', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (10, 'free then use pattern', 'Pointer used after being freed', 'free\s*\(\s*(\w+)\s*\)[^}]*\1\s*->', '["c", "cpp"]', 'CWE-416', 'Use-After-Free', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (11, 'Double free pattern', 'Same pointer freed twice', 'free\s*\(\s*(\w+)\s*\)[^}]*free\s*\(\s*\1\s*\)', '["c", "cpp"]', 'CWE-415', 'Double-Free', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (12, 'access then fopen TOCTOU', 'Time-of-check to time-of-use race condition', 'access\s*\([^)]+\)[^;]*;[^}]*fopen\s*\(', '["c", "cpp"]', 'CWE-367', 'TOCTOU Race Condition', 'Medium', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (13, 'eval on request data', 'eval() called on user request data', 'eval\s*\(\s*request\.', '["py"]', 'CWE-94', 'Code Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (14, 'exec on request data', 'exec() called on user request data', 'exec\s*\(\s*request\.', '["py"]', 'CWE-94', 'Code Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (15, 'pickle on request data', 'Pickle deserialization of untrusted data', 'pickle\.loads?\s*\(\s*request\.', '["py"]', 'CWE-502', 'Insecure Deserialization', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (16, 'os.system with request', 'os.system() with user request data', 'os\.system\s*\(\s*request\.', '["py"]', 'CWE-78', 'Command Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (17, 'subprocess shell=True with user input', 'subprocess with shell=True and user input', 'subprocess\.(run|call|Popen)\s*\([^)]*shell\s*=\s*True[^)]*request\.', '["py"]', 'CWE-78', 'Command Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (18, 'yaml.load unsafe', 'yaml.load without SafeLoader allows code execution', 'yaml\.load\s*\([^)]*\)', '["py"]', 'CWE-502', 'Insecure Deserialization', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (19, '__import__ with user input', 'Dynamic import with user-controlled module name', '__import__\s*\(\s*request\.', '["py"]', 'CWE-94', 'Code Injection', 'Critical', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (20, 'Hardcoded password', 'Hardcoded password in source code', '(password|passwd|pwd)\s*=\s*["\''][^"\'']{4,}["\'']', '["c", "cpp", "py", "js", "java"]', 'CWE-798', 'Hardcoded Credentials', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (21, 'Hardcoded API key', 'Hardcoded API key in source code', '(api_key|apikey|api_secret)\s*=\s*["\''][^"\'']{8,}["\'']', '["c", "cpp", "py", "js", "java"]', 'CWE-798', 'Hardcoded Credentials', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (22, 'Hardcoded secret/token', 'Hardcoded secret or token in source code', '(secret|token|auth_token)\s*=\s*["\''][^"\'']{8,}["\'']', '["c", "cpp", "py", "js", "java"]', 'CWE-798', 'Hardcoded Credentials', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (23, 'SQL string concatenation', 'SQL query built with string concatenation', '(SELECT|INSERT|UPDATE|DELETE)[^"\'']*\+\s*\w+', '["py", "js", "java"]', 'CWE-89', 'SQL Injection', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);
INSERT INTO static_rules (id, name, description, pattern, languages, cwe_id, vulnerability_type, severity, is_definite, requires_llm_verification, enabled, built_in, match_count, created_at, updated_at) VALUES (24, 'SQL f-string interpolation', 'SQL query built with f-string interpolation', 'f["\''].*?(SELECT|INSERT|UPDATE|DELETE).*?\{', '["py"]', 'CWE-89', 'SQL Injection', 'High', 1, 0, 1, 1, 0, '2025-11-26 01:48:16', NULL);

-- Table: vulnerability_categories (26 rows)
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (1, 'CWEâ€‘124: **Buffer Underâ€‘read** (also related to CWEâ€‘120: **Buffer Copy without Checking Size**)', NULL, 'CWE', NULL, '["cwe", "124", "buffer", "under", "read", "also", "related", "cwe", "120", "buffer", "copy", "without", "checking", "size"]', 336, '2025-11-26 02:13:45');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (2, 'CWEâ€‘20 â€“ Improper Input Validation (leads to Arbitrary Code Execution)', 'CWE-20', 'CWE', NULL, '["improper", "input", "validation", "leads", "arbitrary", "code", "execution"]', 28, '2025-12-02 20:45:57');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (3, 'CWEâ€‘401: Missing Release of Memory after Effective Lifetime', 'CWE-401', 'CWE', NULL, '["missing", "release", "memory", "after", "effective", "lifetime"]', 56, '2025-12-02 20:45:57');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (4, 'CWEâ€‘200 â€“ Exposure of Sensitive Information to an Unauthorized Actor', 'CWE-200', 'CWE', NULL, '["exposure", "sensitive", "information", "unauthorized", "actor"]', 48, '2025-12-02 20:46:37');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (5, 'CWEâ€‘190 â€“ Integer Overflow or Wraparound', 'CWE-190', 'CWE', NULL, '["integer", "overflow", "wraparound"]', 42, '2025-12-02 20:46:37');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (6, 'CWEâ€‘126: Buffer Overâ€‘read', 'CWE-126', 'CWE', NULL, '["buffer", "over", "read"]', 7, '2025-12-02 20:46:37');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (7, 'CWEâ€‘119: Improper Restriction of Operations within the Bounds of a Memory Buffer', 'CWE-119', 'CWE', NULL, '["improper", "restriction", "operations", "within", "bounds", "memory", "buffer"]', 36, '2025-12-02 20:47:35');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (8, 'CWEâ€‘125: Outâ€‘ofâ€‘bounds Read', 'CWE-125', 'CWE', NULL, '["out", "bounds", "read"]', 20, '2025-12-02 20:53:59');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (9, 'CWEâ€‘362: Race Condition', 'CWE-362', 'CWE', NULL, '["race", "condition"]', 28, '2025-12-02 20:57:54');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (10, 'CWEâ€‘388 â€“ **Error Handling (Missing Check for Return Value)**', 'CWE-388', 'CWE', NULL, '["error", "handling", "missing", "check", "for", "return", "value"]', 20, '2025-12-02 20:59:35');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (11, 'CWEâ€‘835 â€“ Loop with Unreachable Exit Condition', 'CWE-835', 'CWE', NULL, '["loop", "with", "unreachable", "exit", "condition"]', 1, '2025-12-02 21:04:56');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (12, 'CWEâ€‘284: Improper Access Control', 'CWE-284', 'CWE', NULL, '["improper", "access", "control"]', 10, '2025-12-02 21:05:29');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (13, 'CWEâ€‘327: Use of a Weak Cryptographic Algorithm', 'CWE-327', 'CWE', NULL, '["use", "weak", "cryptographic", "algorithm"]', 6, '2025-12-02 21:05:29');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (14, 'CWEâ€‘415: Double Free', 'CWE-415', 'CWE', NULL, '["double", "free"]', 2, '2025-12-02 21:06:12');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (15, 'CWEâ€‘306: Missing Authentication', 'CWE-306', 'CWE', NULL, '["missing", "authentication"]', 5, '2025-12-02 21:06:46');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (16, 'CWEâ€‘476 â€“ NULL Pointer Dereference', 'CWE-476', 'CWE', NULL, '["null", "pointer", "dereference"]', 26, '2025-12-02 21:12:20');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (17, 'CWEâ€‘121: Stackâ€‘Based Buffer Overflow', 'CWE-121', 'CWE', NULL, '["stack", "based", "buffer", "overflow"]', 4, '2025-12-02 21:14:21');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (18, 'CWEâ€‘665: Improper Initialization (logic error that skips securityâ€‘critical functionality)', 'CWE-665', 'CWE', NULL, '["improper", "initialization", "logic", "error", "that", "skips", "security", "critical", "functionality"]', 5, '2025-12-02 21:17:15');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (19, 'CWEâ€‘400 â€“ Uncontrolled Resource Consumption (also related to CWEâ€‘789 â€“ Uncontrolled Memory Allocation)', 'CWE-400', 'CWE', NULL, '["uncontrolled", "resource", "consumption", "also", "related", "uncontrolled", "memory", "allocation"]', 5, '2025-12-02 21:18:10');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (20, 'CWEâ€‘416: Use After Free', 'CWE-416', 'CWE', NULL, '["use", "after", "free"]', 2, '2025-12-02 21:20:43');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (21, 'CWEâ€‘269: Improper Privilege Management', 'CWE-269', 'CWE', NULL, '["improper", "privilege", "management"]', 1, '2025-12-02 21:31:23');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (22, 'CWEâ€‘124: Buffer Overflow (Write)', 'CWE-124', 'CWE', NULL, '["buffer", "overflow", "write"]', 2, '2025-12-02 21:37:04');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (23, 'CWEâ€‘590: **Free of Invalid Pointer**', 'CWE-590', 'CWE', NULL, '["free", "invalid", "pointer"]', 1, '2025-12-02 21:38:09');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (24, 'CWEâ€‘131: Incorrect Calculation of Buffer Size', 'CWE-131', 'CWE', NULL, '["incorrect", "calculation", "buffer", "size"]', 2, '2025-12-02 21:48:56');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (25, 'CWEâ€‘571 *Expression Is Always False* (misâ€‘interpreted result)', 'CWE-571', 'CWE', NULL, '["expression", "always", "false", "mis", "interpreted", "result"]', 1, '2025-12-02 22:10:38');
INSERT INTO vulnerability_categories (id, name, cwe_id, short_name, description, keywords, usage_count, created_at) VALUES (26, 'CWEâ€‘285 â€“ Improper Authorization', 'CWE-285', 'CWE', NULL, '["improper", "authorization"]', 1, '2025-12-02 22:15:47');

-- Table: tuning_prompt_templates (26 rows)
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (9, 'v1_code_first', 'Imported from test_library (format variant v1_code_first)', '```c
{code}
```

Claim: {claim}

Vote: FALSE_POSITIVE | REAL | NEEDS_VERIFIED | WEAKNESS
Confidence: 0-100
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (10, 'v2_verdict_first', 'Imported from test_library (format variant v2_verdict_first)', 'Vote on this claim.

Options: FALSE_POSITIVE (safe) | REAL (exploitable) | NEEDS_VERIFIED (unclear) | WEAKNESS (not exploitable)

Claim: {claim}

Code:
```c
{code}
```

Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (11, 'v3_numbered', 'Imported from test_library (format variant v3_numbered)', '1. CLAIM
{claim}

2. CODE
```c
{code}
```

3. VERDICT
Vote: [FALSE_POSITIVE|REAL|NEEDS_VERIFIED|WEAKNESS]
Confidence: [0-100]
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (12, 'v4_question', 'Imported from test_library (format variant v4_question)', 'Is this a vulnerability?

Claim: {claim}

Code:
```c
{code}
```

Vote: FALSE_POSITIVE | REAL | NEEDS_VERIFIED | WEAKNESS
Confidence: 0-100
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (13, 'v5_checklist', 'Imported from test_library (format variant v5_checklist)', 'Code:
```c
{code}
```

Claim: {claim}

Checklist:
â–¡ Vulnerability exists?
â–¡ Exploitable?
â–¡ Mitigations?

Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (14, 'v6_expert', 'Imported from test_library (format variant v6_expert)', 'You are a UEFI security expert.

Code:
```c
{code}
```

Claim: {claim}

Expert assessment:
Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (15, 'v7_minimal', 'Imported from test_library (format variant v7_minimal)', 'Code:
```c
{code}
```

Claim: {claim}

Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (16, 'v8_context_last', 'Imported from test_library (format variant v8_context_last)', 'Review this code.

Vote options: FALSE_POSITIVE | REAL | NEEDS_VERIFIED | WEAKNESS

```c
{code}
```

Claim: {claim}

Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (17, 'v9_bullets', 'Imported from test_library (format variant v9_bullets)', 'Vulnerability Report:

â€¢ Issue: {issue}
â€¢ File: {file}
â€¢ Claim: {claim}

Code:
```c
{code}
```

Analysis:
â€¢ Vote: [FALSE_POSITIVE|REAL|NEEDS_VERIFIED|WEAKNESS]
â€¢ Confidence: [0-100]
â€¢ Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (18, 'v10_table', 'Imported from test_library (format variant v10_table)', '| Field | Value |
|-------|-------|
| Issue | {issue} |
| File | {file} |
| Claim | {claim} |

Code:
```c
{code}
```

Verdict:
| Vote | |
| Confidence | |
| Reasoning | |', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (19, 'v11_socratic', 'Imported from test_library (format variant v11_socratic)', 'Code:
```c
{code}
```

Claim: {claim}

Questions:
1. Where is the issue?
2. What triggers it?
3. Can attacker control it?
4. What''s the impact?
5. Any protections?

Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (20, 'v12_redteam', 'Imported from test_library (format variant v12_redteam)', 'RED TEAM: Try to exploit this.

```c
{code}
```

Claim: {claim}

If exploitable â†’ REAL
If safe â†’ FALSE_POSITIVE
If unclear â†’ NEEDS_VERIFIED
If bad code but safe â†’ WEAKNESS

Vote:
Confidence:
Attack:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (21, 'v13_diff', 'Imported from test_library (format variant v13_diff)', '--- Scanner View ---
VULNERABLE: {claim}

--- Actual Code ---
```c
{code}
```

--- Analysis ---
Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (22, 'v14_emoji', 'Imported from test_library (format variant v14_emoji)', 'ðŸ” SECURITY ANALYSIS

ðŸ“„ Code:
```c
{code}
```

âš ï¸ Alert: {claim}

ðŸ¤” Assessment:
â€¢ Vote:
â€¢ Confidence:
â€¢ Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (23, 'v15_json', 'Imported from test_library (format variant v15_json)', '{{
  "code": "{code}",
  "claim": "{claim}",
  "analysis": {{
    "vote": "",
    "confidence": 0,
    "reasoning": ""
  }}
}}', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (24, 'v16_markdown', 'Imported from test_library (format variant v16_markdown)', '# Vulnerability Assessment

## Code
```c
{code}
```

## Claim
{claim}

## Analysis

### Vote
[FALSE_POSITIVE|REAL|NEEDS_VERIFIED|WEAKNESS]

### Confidence
[0-100]

### Reasoning
', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (25, 'v17_xml', 'Imported from test_library (format variant v17_xml)', '<analysis>
  <code>{code}</code>
  <claim>{claim}</claim>
  <verdict>
    <vote></vote>
    <confidence></confidence>
    <reasoning></reasoning>
  </verdict>
</analysis>', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (26, 'v18_prose', 'Imported from test_library (format variant v18_prose)', 'Review this code and claim.

Code: {code}

Claim: {claim}

Provide your assessment with vote (FALSE_POSITIVE/REAL/NEEDS_VERIFIED/WEAKNESS), confidence (0-100), and detailed reasoning.', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (27, 'v19_skeptic', 'Imported from test_library (format variant v19_skeptic)', 'SKEPTICAL REVIEW: Assume scanner is wrong.

Code:
```c
{code}
```

Claim: {claim}

Find reasons this is FALSE_POSITIVE. Only vote REAL if you can''t dismiss it.

Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (28, 'v20_stepwise', 'Imported from test_library (format variant v20_stepwise)', 'Step-by-step analysis.

Code:
```c
{code}
```

Claim: {claim}

Step 1: What does code do?
Step 2: Where is alleged vulnerability?
Step 3: Is it exploitable?
Step 4: Mitigations?

Conclusion:
Vote:
Confidence:
Reasoning:', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (29, 'v21_chain_of_thought', 'Imported from test_library (format variant v21_chain_of_thought)', 'You are a senior security researcher. Verify this finding.

=== FINDING ===
Title: {claim}
File: {file}
Issue: {issue}

=== CODE ===
```{language}
{code}
```

=== INSTRUCTIONS ===
1. Analyze the data flow from input to sink.
2. Check for validation or sanitization in the context.
3. Determine if this is a FALSE POSITIVE (safe), WEAKNESS (bad practice but not exploitable), or REAL (exploitable).

Thinking Process:
<thinking>
[Analyze the code step-by-step here]
</thinking>

=== VERDICT ===
*VOTE: [REAL / FALSE_POSITIVE / WEAKNESS]
*CONFIDENCE: [0-100]
*REASONING: [Summary of your analysis]', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (30, 'v22_adversarial_expert', 'Imported from test_library (format variant v22_adversarial_expert)', 'You are an offensive security expert. Your goal is to prove this code is EXPLOITABLE.

Target: {file}
Vulnerability Claim: {claim}

Code:
```
{code}
```

=== MISSION ===
Try to construct a valid attack scenario.
- If you can prove an exploit path exists -> VOTE REAL.
- If the code prevents exploitation (bounds checks, types, logic) -> VOTE FALSE_POSITIVE.
- If it''s theoretically bad but you can''t exploit it -> VOTE WEAKNESS.

=== OUTPUT ===
*ATTACK_SCENARIO: [Describe how you would exploit this, or why you failed]
*VOTE: [REAL / FALSE_POSITIVE / WEAKNESS]
*CONFIDENCE: [0-100]
*REASONING: [Explain your verdict]', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (31, 'v23_maintainer_review', 'Imported from test_library (format variant v23_maintainer_review)', 'You are the maintainer of this repository. A static analysis tool flagged this code.

File: {file}
Flagged Issue: {issue}

Code:
```
{code}
```

Would you block this Pull Request?
- YES (Critical vulnerability) -> REAL
- MAYBE (Bad practice/Clean up needed) -> WEAKNESS
- NO (This is fine/False alarm) -> FALSE_POSITIVE

*VOTE: [REAL / FALSE_POSITIVE / WEAKNESS]
*CONFIDENCE: [0-100]
*REASONING: [Explanation for the contributor]', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (32, 'v24_data_flow_analysis', 'Imported from test_library (format variant v24_data_flow_analysis)', 'Perform a Data Flow Analysis to verify this vulnerability.

Claim: {claim}

Code:
```
{code}
```

Trace the data:
1. Identify the Source (where input comes from).
2. Identify the Sink (dangerous function).
3. Check all intermediate steps for Sanitization or Validation.

If Source -> Sink exists without Validation -> REAL.
Otherwise -> FALSE_POSITIVE.

*VOTE: [REAL / FALSE_POSITIVE / WEAKNESS]
*CONFIDENCE: [0-100]
*REASONING: [Describe the data path]', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (33, 'v25_security_standards', 'Imported from test_library (format variant v25_security_standards)', 'Evaluate this finding against standard security guidelines (OWASP, CWE).

Issue: {issue}
Claim: {claim}

Code:
```
{code}
```

Does this code violate specific security standards in an exploitable way?
Cite the specific CWE or mechanism that allows exploitation.

*VOTE: [REAL / FALSE_POSITIVE / WEAKNESS]
*CONFIDENCE: [0-100]
*REASONING: [Technical analysis citing standards]', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_prompt_templates (id, name, description, template, created_at, updated_at) VALUES (34, 'v26_strict_json', 'Imported from test_library (format variant v26_strict_json)', 'Analyze this code for vulnerabilities.

Issue: {issue}
Code:
```
{code}
```

Return ONLY a JSON object. No markdown, no prose.
{{
  "vote": "REAL" | "FALSE_POSITIVE" | "WEAKNESS",
  "confidence": 0-100,
  "reasoning": "string"
}}', '2025-12-11 21:42:59', NULL);

-- Table: tuning_test_cases (13 rows)
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (1, '221_integer_overflow', 'FALSE_POSITIVE', NULL, 'Integer Overflow in ROM Size Calculation', 'BootManagerDxe/Legacy.c:4450', 'ImageSize = ((EFI_LEGACY_EXPANSION_ROM_HEADER *)LocalRomImage)->Size512 * 512;
Status = (gBS->AllocatePages)(AllocateMaxAddress, EfiBootServicesCode, EFI_SIZE_TO_PAGES(ImageSize), &PhysicalAddress);
if (EFI_ERROR(Status)) { return EFI_OUT_OF_RESOURCES; }
CopyMem((VOID *)PhysicalAddress, LocalRomImage, ImageSize);', 'Size512 is 16-bit; multiplying by 512 can overflow 32-bit UINTN, causing smaller ImageSize and buffer overflow', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (2, '213_nvram_size', 'REAL', NULL, 'Missing size validation for NVRAM variable', 'BootManagerDxe/BootManager.c:1791', 'SctLibGetVariable(PBA_STATUS_VAR_NAME, &PbaStatusVarGuid, &Attributes, &VarSize, (VOID**)&PbaStatusVar);
if (EFI_ERROR(Status) || VarSize == 0) { return SCT_STATUS_INVALID_DATA; }
if (PbaStatusVar->IdentifyOnBoot != 0) { UPDATE_HOTKEY_STATES(mTextInEx); }', 'Checks VarSize != 0 but doesn''t verify VarSize >= sizeof(PBA_STATUS_VAR) before dereferencing', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (3, '215_osindications', 'REAL', NULL, 'Missing UINT64 size check', 'BootManagerDxe/BootManager.c:1972', 'SctLibGetVariable(L"OsIndications", &gEfiGlobalVariableGuid, NULL, &DataSize, (VOID **)&OsIndications);
if (!EFI_ERROR(Status)) {
  if (*OsIndications & EFI_OS_INDICATIONS_FILE_CAPSULE_DELIVERY_SUPPORTED) {
    *OsIndications &= ~EFI_OS_INDICATIONS_FILE_CAPSULE_DELIVERY_SUPPORTED;
  }
}', 'Assumes OsIndications is UINT64 but never verifies DataSize == sizeof(UINT64)', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (4, '211_bootnext', 'REAL', NULL, 'Missing BootNext variable size validation', 'BootManagerDxe/BootManager.c:1279', 'Status = GetBootOption(*BootNextValue, &Option);
if (EFI_ERROR(Status) || Option == NULL) { /* error */ }', 'Assumes BootNext contains UINT16 without size confirmation', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (5, '216_null_deref', 'REAL', NULL, 'Null pointer dereference in array sorting', 'BootManagerDxe/BootManager.c:4138', 'for (i = HandleCount - 1; i > 0; i--) {
  for (j = 0; j < i; j++) {
    if ((ImagePackage[j])->ZValue > (ImagePackage[j + 1])->ZValue) {
      Temp = ImagePackage[j]; ImagePackage[j] = ImagePackage[j + 1]; ImagePackage[j + 1] = Temp;
    }
  }
}', 'ImagePackage[j] may be NULL if OpenProtocol failed; no null-check before dereference', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (6, '218_uninit_ptr', 'REAL', NULL, 'Uninitialized function pointer', 'BootManagerDxe/BootManager.c:192', 'return Item->mOldPciIoAttributes(This, Operation, Attributes, Result);', 'mOldPciIoAttributes only initialized conditionally; may be uninitialized when invoked', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (7, '220_ide_overflow', 'REAL', NULL, 'Array index overflow', 'BootManagerDxe/Legacy.c:1366', 'IbvBbs->IdeDiskInfo[IdeInfo].DiskInfoDeviceType = BBS_IDE_HDD_DEVICE_TYPE;', 'IdeInfo incremented without bounds check against IdeDiskInfo array size', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (8, '223_hdd_oob', 'REAL', NULL, 'Out-of-bounds array access', 'BootManagerDxe/Legacy.c:1665', 'if (((HddInfo[HddInfoIndex].Status & HDD_PRIMARY) != 0) ...) { ... }', 'HddInfoIndex from BbsOrder without bounds checking', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (9, '230_smi_null', 'REAL', NULL, 'NULL pointer dereference', 'BootManagerDxe/Legacy.c:4193', 'Status = SwSmiAllocator->QuerySwSmi(&mCsmSwSmiGuidArray[SCT_CSM_LEGACY_USB_BY_IRQ], &CsmSwSmiInputValue);', 'SwSmiAllocator may be NULL if protocol lookup fails', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (10, '232_bbs_overflow', 'REAL', NULL, 'Out-of-bounds write to BbsTable', 'BootManagerDxe/Legacy.c:5338', 'BbsTableDevicePaths[i] = DuplicateDevicePath(DevicePath);
BbsTable[i].BootPriority = BBS_UNPRIORITIZED_ENTRY;', 'Index i equals BbsCount, allowing writes past allocated tables', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (11, '233_buffer_index', 'REAL', NULL, 'Unchecked buffer indexing', 'BootManagerDxe/Legacy.c:5486', 'if (BbsTableDevicePaths[Buffer[Index]] != NULL) { ... }', 'Buffer[Index] used without bounds verification', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (12, '234_int_overflow', 'REAL', NULL, 'Integer overflow in size calculation', 'BootManagerDxe/BootManager.c:5939', '*OptionalDataLength += (UINT32)GetDevicePathSize(*DevicePath);', 'Adding large value without overflow check may wrap size', '2025-12-11 21:42:59', NULL);
INSERT INTO tuning_test_cases (id, name, verdict, draft_finding_id, issue, file, code, claim, created_at, updated_at) VALUES (13, '235_loop_overflow', 'REAL', NULL, 'Loop counter overflow / infinite loop', 'BootManagerDxe/BootManager.c:1049', 'for (j = 0; j < (mProtectedBootOptionsSize / sizeof(UINT16)); j++) { ... }', 'Loop counter j is UINT16; if size > 0xFFFF*2, comparison wraps causing infinite loop', '2025-12-11 21:42:59', NULL);

-- Table: users (1 rows)
INSERT INTO users (id, email, display_name, hashed_password, role, status, created_at, approved_at, approved_by_id, last_login) VALUES (1, 'admin', 'Administrator', '$argon2id$v=19$m=65536,t=2,p=1$zqXAqbjSgeYIdmVe8qInmw$FKFHWzZDtK6/r8eV0oyXUp3LBs5InsZEBzJqNajigBI', 'admin', 'active', '2025-12-12 12:23:23.288910', NULL, NULL, NULL);

